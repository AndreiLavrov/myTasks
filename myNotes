'<=' - правильно, а '=<' - не прав. сначало '<', а потом '='
(a <= item && item <= b) а не (a <= item <= b)
' let sumProd = 0;' лучше, чем 'let sumProd;' задавать значение..
str.split(badWord).join(goodWord); -слова в роле разделителей...ЗАМЕНИТЬ ненужные слова
person['name'] === person.name  (var key = 'name'; person[key])  если имя свойства хранится в переменной (var key = "name"),
 то единственный способ к нему обратиться – это квадратные скобки person[key].
[1,2] !== [1,2];

{}[0]   // то же что и: [0] или {} + {} // то же что и: + {}  если { ... } находится вне выражений, то это не объект, а блок.

У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования
 используется toString.








                 для изучения !!
eslint  (откоррект. настройки )
jasmine  (норм)
moment!!!  (изучить)
koans

*************** ВОПРОСЫ  ***********************
не работает в прототиппе из-за того что в Required есть свой toString? почему не наследует от класса-родителя ? les9 'validators'
разница в ошибках между ошибкой на сервере и ошибкой не состоявшейся связи с сервером les10 и как
заставить fetch возвращать сразу ошибку при не прав. url ??

при запросе от сервера(fetch или просто promise) какая разница ипользовать catch или reject ??   (les10 myHt.js)

коректно ли так вызывать formControlInput,  передавая параметром??????  les12/task1_ES6/formControl

почему если указать обработчик соб. в html, то getPosts is not defined? (скрипт менял местами) (les12 myHt.js)

helper через парам в CLASS  чем разница ??                                  нету, жестко привязываешь...
что не так, когда 'addClass' выносишь в прототип les9                      возвращаешь ф-ию без ее вызова

примеси





*************************   les3
1. isTriangle ты проверяешь только одну сторону надо три втвоем случае isTriangle(1, 0, 2) будет треугольником,
2. findShort - не совсем понятно почему let shortest = 15;
надо было так let shortest = arrFromString[0].length

********                        les4
1. добавляй лучше полноценные коменты
/**
 *  division without remainder
 * @param a
 * @param b
  @returns {}
 */

2. vowels
можно не писать большые буквы только маленькие
и сделать str = str.toLowerString() ну или при сравнение

3.sumProducts - старайся делать функции с консистентными данными, функция должна возвращать ожидаемый результат,
 т.е если ты пишешь подсчет суммы то она должна возвращать число если продуктов нет то 0. т.к. если ты будешь использовать sum
 в других функциях возврат строки придется отдельно обрабатывать

4. cart.forEach(function (item, i, arrProd) {
		sumProd += +arrProd[i].costPerUnit * +arrProd[i].numberOfUnits;
	} );
тут наверное лучше item сразу брать, смысла нет добавлять массив и индекс брать
sumProd += +current.costPerUnit * +current.numberOfUnits;

5. removeProd тоже что и в 4 и там лучше фильтр юзать
и то же самое если возвращаешь cart то если cart пустая то лучше вернуть []

*******************         les5

функция сравнения, ты даты сравниваешь как строки, если у тебя в будущем придет объект с другим форматом даты что то может пойти не так,
 всегда старайся думать о переиспользовании и расширяемости
**********************       les7

можно было получать arguments , конвертить его в массив и применять не call а apply с массивом который получили из arguments,
 предварительно в него добавив оставшиеся параметры
*********************        les8
при copy past всегда убедись что копируемые функции абсолютно идентичны..
принцип единственной ответственности и пр. открытости/закрытости для функций(класса)
*********************        les9
помнить о отсутствии всплытия и очередности объявления переменных и их использ.  в функциях(если замен функцию на аналогичную, то ставить рядом)
*********************        les10
разница в ошибках между ошибкой на сервере и ошибкой не состоявшейся связи с сервером
Cache-Control

Мы очень серьезно относимся к безопасности в Dark Sky. В качестве меры безопасности мы отключили обмен ресурсами между источниками (CORS) на наших серверах.

Ваш вызов API включает в себя ваш секретный ключ API как часть запроса. Если бы вам приходилось совершать вызовы API из клиентского кода, любой мог бы извлечь и использовать ваш ключ API, что привело бы к счету, который вам пришлось бы оплатить. Мы отключаем CORS, чтобы сохранить секретный ключ вашего API в секрете.

Чтобы предотвратить злоупотребление ключами API, вы должны настроить прокси-сервер для скрытого вызова нашего API. Затем вы можете предоставлять прогнозы своим клиентам, не раскрывая свой ключ API.
**************** **         les11
названия файлов писать через "-"
******************          les12
если использовать метод веутри метода то с 'this'


******************          les15
использовать именованные а не ананимные функции в обработчике события (для удаления или изменения)


*************            Ajax
Существует два вида взаимодействия с сервером:

- одноразовый запрос/ответ (Ajax);
- постоянный обмен данными (Comet);
Одноразовые запросы реализуются с помощью:

- submit обычной HTML-формы;
- тег <script src=""> (протокол JSONP);
или с помощью встроенных объектов js:

- XMLHttpRequest (а также его более поздняя версия XMLHttpRequest-2);
- промисы fetch();
Для постоянного обмена данными используются технологии:

- частые одноразовые опросы (Polling);
- длительное соединение в ожидании ответа сервера с последующим повторением запроса (Long Polling / Hanging GET) - реализуется с помощью  объектов js  из одноразовых запросов;
- длительное непрерывное одностороннее соединение, при котором клиент делает запрос всего один раз (может быть чаще, если происходит обрыв), а остальное время данные шлёт только сервер - реализуется с помощью "бесконечного" IFRAME и Server Side Events;
- длительное непрерывное двустороннее соединение, где сервер и клиент полноценно обмениваются данными - реализуется с помощью WebSocket;

*************************** ESLINT ***********************
toMatch
toBeDefined
toBeNull
toBeTruthy
toContain
toBeLessThan toBeGreaterThan
toBeCloseTo  точн матем сравнение
toThrow
toThrowError
..spyOn...
toHaveBeenCalled   - что был вызван  toHaveBeenCalledWith - был вызван с аргументами
and.callThrough   - перехват выполнения
and.returnValue  - все вызовы функции будут возвращать определенное значение.
and.callFake    - все вызовы шпиону будут делегированы предоставленной функции
and.throwError   - всеми вызовами шпиону throw указанное значение будет считаться ошибкой.
and.stub    -   исходное поведение 'окурка' может быть возвращено в любое время с помощью
.calls.any(): возвращает, false если шпион вообще не был вызван, а затем true один раз произойдет хотя бы один вызов.
.calls.count(): возвращает количество вызовов шпиона
.calls.argsFor(index): возвращает аргументы, переданные на номер вызова index

.calls.allArgs(): возвращает аргументы для всех вызовов
.calls.all(): возвращает контекст (the this) и аргументы, переданные всем вызовам
.calls.mostRecent(): возвращает контекст (the this) и аргументы для самого последнего вызова
.calls.first(): возвращает контекст (the this) и аргументы для первого вызова
.calls.first().object --  "object-свойство" устанавливается равным значению, thisкогда был вызван шпион
expect(foo).toHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));

.calls.reset(): очищает все отслеживания для шпиона
expect({}).toEqual(jasmine.any(Object));
jasmine.objectContaining  -- когда ожидание заботится только об определенных парах ключ / значение в фактическом.
jasmine.clock().install     jasmine.clock().tick    --- для таймаутов

