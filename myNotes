'<=' - правильно, а '=<' - не прав. сначало '<', а потом '='
(a <= item && item <= b) а не (a <= item <= b)
' let sumProd = 0;' лучше, чем 'let sumProd;' задавать значение..
str.split(badWord).join(goodWord); -слова в роле разделителей...ЗАМЕНИТЬ ненужные слова
person['name'] === person.name  (var key = 'name'; person[key])  если имя свойства хранится в переменной (var key = "name"),
 то единственный способ к нему обратиться – это квадратные скобки person[key].
[1,2] !== [1,2];

{}[0]   // то же что и: [0] или {} + {} // то же что и: + {}  если { ... } находится вне выражений, то это не объект, а блок.

У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования
 используется toString.

getElementsByTagName – живая коллекцияquerySelector, наоборот, возвращает статичный список узлов

 innerHTML -- текст от посетителя вставился именно как HTML, то есть теги стали именно тегами, а textContent – как обычный текст.
textContent -- посетители вставляли в наш сайт произвольный HTML-код. Присваивание через textContent – один из способов от этого защититься

TEXTAREA.value (не innerHTML!!!)

для проверки адреса ссылки: свойство href или атрибут getAttribute('href')?Здесь нужен именно атрибут, хотя бы потому, что в свойстве все ссылки
 уже с хостом и протоколом, а нам надо понять, был ли протокол в href или нет

стараться анимировать абсолютно и фиксированно позиционированные элементы, т.к. их положение и размер не влияют на размеры их родителя,
а следовательно и всех остальных элементов страницы.

по возможности, анимировать только стилевые свойства transform, opacity, filter.

//******
Чтобы CSS-анимация DOM-элемента была плавной и производительной:
Сделать элемент позиционированным (position: absolute).
Вынести элемент на GPU-слой (transform: translateZ(0) и will-change: transform).
При анимации позиции элемента — анимировать стилевое свойство transform (а не left/top, margin и др.).
В остальных случаях — желательно обойтись анимацией стилевых свойств transform, opacity, filter.
Чтобы JavaScript-анимация DOM-элемента была плавной и производительной:
Изменения вносить в момент requestAnimationFrame (а не в обработчиках событий мыши, скроллинга, изменения размера...).
Сделать элемент позиционированным.
Вынести элемент на GPU-слой.
При анимации позиции элемента — анимировать стилевое свойство transform.
В остальных случаях — желательно обойтись анимацией стилевых свойств transform, opacity, filter.
/*****

способ для копирования? объектов JSON.parse(JSON.stringify(obj))

не создавать случайно новый класс (прав. импортить класс в другой класс, передавать параметром)

http://localhost:8082/  -- только это в строке для les14-SPA

следи чтобы названия классов не пересекались...


                 для изучения !!
eslint  (откоррект. настройки )
jasmine  (норм)
moment!!!  (изучить)
koans

*************** ВОПРОСЫ  ***********************
? bootstrap
? когда я изменил в webpack.config.js  "entry", то "watch" переписываем ? что конкретно происходит там? поменялся алгоритм сборки бандла?
? преимущества вызова класса через переменную в app-controller.js (les20-MVC) ?
создал свое событие в products-view но оно не работает пустой объект событий в EventEmitter.....нужно чтобы on и emit были у одного класса...
? promise
? как задать свойство от импортируеммого класса в родительском классе ??? при асинхронном получении этого св-ва ??
в классе задавать обработчиком собственный метод, а уже в нем использовать метод другово класса через свойство-класс
? разный угол вбрасыв мяча в теннисе 19
? как отменить событие клавиши (залипание клавиш) в les19-tennis  ?    windows and browser
? зачем добавлять '/'  в container.querySelector('img').setAttribute('src', '/' + item.image.small);  les14/app/152
? при window.location.pathname возвращается на титульную стр хорошо, а window.location.href -- нет...SPA/controller/36
параметр в строке url
*/ первая загрузка, а потом сохранять данные в объекте js
? шаблонизатор для SPA резонно?
? нужно ли объявлять переменную заранее, или можно только в методе(renderAboutPage) 14-SPA  -- нет скорее
? display none  не действует на детей?? лучше подгружать заново
? обработчики событ. в меню навигации лучше вешать на каждую кнопку  отдельно , или на меню и выбирать кнопку по event через
условие ( получиться не совсем гибко...)?
? для SPA отдельно подгрузить как инфу другого типа ?
? eslint пишет только одну ошибку про тип файла должен быть -- метод. и все.. ??
? как заставить элемент прижаться к нижней границе родителя в html ?

? коректно ли так вызывать formControlInput,  передавая параметром??????
? нет, это функция фабрика она должна вернуть этот объект, ей можно передать dom элемент,
- что бы она его распарсила и вернула нужный formControl не понял les12/task1/form-control   ????????

* если использовать метод веутри метода то с 'this'    да!
? не работает с классами в les10/ht_es6 yt почему ? GET http://localhost:63342/myTasks/les10/ht_es6/task2 net::ERR_ABORTED 404 (Not Found) ?
* npm устанавливать как , чтобы не в каждую папку..общий можно ?? не желательно.. для проекта свой лучше..
? не работает в прототиппе из-за того что в Required есть свой toString? почему не наследует от класса-родителя ? les9 'validators'
*? разница в ошибках между ошибкой на сервере и ошибкой не состоявшейся связи с сервером les10 и как
* заставить fetch возвращать сразу ошибку при не прав. url ??

? параметр === MouseEvent {isTrusted: true, screenX: 32     (les10/myHt.js)

* при запросе от сервера(fetch или просто promise) какая разница ипользовать catch или reject ??   (les10 myHt.js)
-- reject дает вариативность ошибки(выбрать что мы считаем ошибкой)

? коректно ли так вызывать formControlInput,  передавая параметром??????  les12/task1_ES6/formControl

? почему если указать обработчик соб. в html, то getPosts is not defined? (скрипт менял местами) (les12 myHt.js)

* helper через парам в CLASS  чем разница ??                                  нету, жестко привязываешь...
* что не так, когда 'addClass' выносишь в прототип les9                      возвращаешь ф-ию без ее вызова

примеси





*************************   les3
1. isTriangle ты проверяешь только одну сторону надо три втвоем случае isTriangle(1, 0, 2) будет треугольником,
2. findShort - не совсем понятно почему let shortest = 15;
надо было так let shortest = arrFromString[0].length

********                        les4
1. добавляй лучше полноценные коменты
/**
 *  division without remainder
 * @param a
 * @param b
  @returns {}
 */

2. vowels
можно не писать большые буквы только маленькие
и сделать str = str.toLowerString() ну или при сравнение

3.sumProducts - старайся делать функции с консистентными данными, функция должна возвращать ожидаемый результат,
 т.е если ты пишешь подсчет суммы то она должна возвращать число если продуктов нет то 0. т.к. если ты будешь использовать sum
 в других функциях возврат строки придется отдельно обрабатывать

4. cart.forEach(function (item, i, arrProd) {
		sumProd += +arrProd[i].costPerUnit * +arrProd[i].numberOfUnits;
	} );
тут наверное лучше item сразу брать, смысла нет добавлять массив и индекс брать
sumProd += +current.costPerUnit * +current.numberOfUnits;

5. removeProd тоже что и в 4 и там лучше фильтр юзать
и то же самое если возвращаешь cart то если cart пустая то лучше вернуть []

*******************         les5

функция сравнения, ты даты сравниваешь как строки, если у тебя в будущем придет объект с другим форматом даты что то может пойти не так,
 всегда старайся думать о переиспользовании и расширяемости
**********************       les7

можно было получать arguments , конвертить его в массив и применять не call а apply с массивом который получили из arguments,
 предварительно в него добавив оставшиеся параметры
*********************        les8
при copy past всегда убедись что копируемые функции абсолютно идентичны..
принцип единственной ответственности и пр. открытости/закрытости для функций(класса)
*********************        les9
помнить о отсутствии всплытия и очередности объявления переменных и их использ.  в функциях(если замен функцию на аналогичную, то ставить рядом)
*********************        les10
разница в ошибках между ошибкой на сервере и ошибкой не состоявшейся связи с сервером -- он пытается соединится
пока не произайдет timeout  запрос в состоянии pending
/надо учиться использовать готовый код//
Мы очень серьезно относимся к безопасности в Dark Sky. В качестве меры безопасности мы отключили обмен ресурсами между источниками (CORS) на наших серверах.
Ваш вызов API включает в себя ваш секретный ключ API как часть запроса. Если бы вам приходилось совершать вызовы API из клиентского кода, любой мог бы извлечь и использовать ваш ключ API,
что привело бы к счету, который вам пришлось бы оплатить. Мы отключаем CORS, чтобы сохранить секретный ключ вашего API в секрете.
Чтобы предотвратить злоупотребление ключами API, вы должны настроить прокси-сервер для скрытого вызова нашего API. Затем вы можете предоставлять прогнозы своим клиентам, не раскрывая свой ключ API.
**************** **         les11
названия файлов писать через "-"

this не терять(использовать bind)
******************          les12
если использовать метод веутри метода то с 'this'
файлы называешь ... принято называть так form-control-input.js
тяжковато читать код старайся раставлять все отступы, точки с запятыми и т.д
******************          les15
использовать именованные а не ананимные функции в обработчике события (для удаления или изменения)


*************            Ajax
Существует два вида взаимодействия с сервером:

- одноразовый запрос/ответ (Ajax);
- постоянный обмен данными (Comet);
Одноразовые запросы реализуются с помощью:

- submit обычной HTML-формы;
- тег <script src=""> (протокол JSONP);
или с помощью встроенных объектов js:

- XMLHttpRequest (а также его более поздняя версия XMLHttpRequest-2);
- промисы fetch();
Для постоянного обмена данными используются технологии:

- частые одноразовые опросы (Polling);
- длительное соединение в ожидании ответа сервера с последующим повторением запроса (Long Polling / Hanging GET) - реализуется с помощью  объектов js  из одноразовых запросов;
- длительное непрерывное одностороннее соединение, при котором клиент делает запрос всего один раз (может быть чаще, если происходит обрыв), а остальное время данные шлёт только сервер - реализуется с помощью "бесконечного" IFRAME и Server Side Events;
- длительное непрерывное двустороннее соединение, где сервер и клиент полноценно обмениваются данными - реализуется с помощью WebSocket;

*************************** ESLINT ***********************
toMatch
toBeDefined
toBeNull
toBeTruthy
toContain
toBeLessThan toBeGreaterThan
toBeCloseTo  точн матем сравнение
toThrow
toThrowError
..spyOn...
toHaveBeenCalled   - что был вызван  toHaveBeenCalledWith - был вызван с аргументами
and.callThrough   - перехват выполнения
and.returnValue  - все вызовы функции будут возвращать определенное значение.
and.callFake    - все вызовы шпиону будут делегированы предоставленной функции
and.throwError   - всеми вызовами шпиону throw указанное значение будет считаться ошибкой.
and.stub    -   исходное поведение 'окурка' может быть возвращено в любое время с помощью
.calls.any(): возвращает, false если шпион вообще не был вызван, а затем true один раз произойдет хотя бы один вызов.
.calls.count(): возвращает количество вызовов шпиона
.calls.argsFor(index): возвращает аргументы, переданные на номер вызова index

.calls.allArgs(): возвращает аргументы для всех вызовов
.calls.all(): возвращает контекст (the this) и аргументы, переданные всем вызовам
.calls.mostRecent(): возвращает контекст (the this) и аргументы для самого последнего вызова
.calls.first(): возвращает контекст (the this) и аргументы для первого вызова
.calls.first().object --  "object-свойство" устанавливается равным значению, thisкогда был вызван шпион
expect(foo).toHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));

.calls.reset(): очищает все отслеживания для шпиона
expect({}).toEqual(jasmine.any(Object));
jasmine.objectContaining  -- когда ожидание заботится только об определенных парах ключ / значение в фактическом.
jasmine.clock().install     jasmine.clock().tick    --- для таймаутов

