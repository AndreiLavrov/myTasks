'<=' - правильно, а '=<' - не прав. сначало '<', а потом '='
(a <= item && item <= b) а не (a <= item <= b)
' let sumProd = 0;' лучше, чем 'let sumProd;' задавать значение..
str.split(badWord).join(goodWord); -слова в роле разделителей...ЗАМЕНИТЬ ненужные слова
person['name'] === person.name  (var key = 'name'; person[key])  если имя свойства хранится в переменной (var key = "name"),
 то единственный способ к нему обратиться – это квадратные скобки person[key].
[1,2] !== [1,2];










                 для изучения !!
eslint  (откоррект. настройки )
jasmine  (норм)
moment!!!  (изучить)
koans

*************** ВОПРОСЫ  ***********************
запустить код в панели
tab настроить в webStorm
spyOn(window, 'prompt').and.callFake(function(param) {
			return false;});    вместо фальш раздельная строка не работает!  почему ??
...code review ...






*************************
1. isTriangle ты проверяешь только одну сторону надо три втвоем случае isTriangle(1, 0, 2) будет треугольником,
2. findShort - не совсем понятно почему let shortest = 15;
надо было так let shortest = arrFromString[0].length

***
1. добавляй лучше полноценные коменты
/**
 *  division without remainder
 * @param a
 * @param b
  @returns {}
 */

2. vowels
можно не писать большые буквы только маленькие
и сделать str = str.toLowerString() ну или при сравнение

3.sumProducts - старайся делать функции с консистентными данными, функция должна возвращать ожидаемый результат, т.е если ты пишешь подсчет суммы то она должна возвращать число если продуктов нет то 0. т.к. если ты будешь использовать sum в других функциях возврат строки придется отдельно обрабатывать

4. cart.forEach(function (item, i, arrProd) {
		sumProd += +arrProd[i].costPerUnit * +arrProd[i].numberOfUnits;
	} );
тут наверное лучше item сразу брать, смысла нет добавлять массив и индекс брать
sumProd += +current.costPerUnit * +current.numberOfUnits;

5. removeProd тоже что и в 4 и там лучше фильтр юзать
и то же самое если возвращаешь cart то если cart пустая то лучше вернуть []


*************************** ESLINT ***********************
toMatch
toBeDefined
toBeNull
toBeTruthy
toContain
toBeLessThan toBeGreaterThan
toBeCloseTo  точн матем сравнение
toThrow
toThrowError
..spyOn...
toHaveBeenCalled   - что был вызван  toHaveBeenCalledWith - был вызван с аргументами
and.callThrough   - перехват выполнения
and.returnValue  - все вызовы функции будут возвращать определенное значение.
and.callFake    - все вызовы шпиону будут делегированы предоставленной функции
and.throwError   - всеми вызовами шпиону throw указанное значение будет считаться ошибкой.
and.stub    -   исходное поведение 'окурка' может быть возвращено в любое время с помощью
.calls.any(): возвращает, false если шпион вообще не был вызван, а затем true один раз произойдет хотя бы один вызов.
.calls.count(): возвращает количество вызовов шпиона
.calls.argsFor(index): возвращает аргументы, переданные на номер вызова index

.calls.allArgs(): возвращает аргументы для всех вызовов
.calls.all(): возвращает контекст (the this) и аргументы, переданные всем вызовам
.calls.mostRecent(): возвращает контекст (the this) и аргументы для самого последнего вызова
.calls.first(): возвращает контекст (the this) и аргументы для первого вызова
.calls.first().object --  "object-свойство" устанавливается равным значению, thisкогда был вызван шпион
expect(foo).toHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));

.calls.reset(): очищает все отслеживания для шпиона
expect({}).toEqual(jasmine.any(Object));
jasmine.objectContaining  -- когда ожидание заботится только об определенных парах ключ / значение в фактическом.
jasmine.clock().install     jasmine.clock().tick    --- для таймаутов

