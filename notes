'<=' - правильно, а '=<' - не прав. сначало '<', а потом '='
(a <= item && item <= b) а не (a <= item <= b)
' let sumProd = 0;' лучше, чем 'let sumProd;' задавать значение..
str.split(badWord).join(goodWord); -слова в роле разделителей...ЗАМЕНИТЬ ненужные слова
person['name'] === person.name  (var key = 'name'; person[key])  если имя свойства хранится в переменной (var key = "name"),
 то единственный способ к нему обратиться – это квадратные скобки person[key].
[1,2] !== [1,2];

{}[0]   // то же что и: [0] или {} + {} // то же что и: + {}  если { ... } находится вне выражений, то это не объект, а блок.

У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования
 используется toString.








                 для изучения !!
eslint  (откоррект. настройки )
jasmine  (норм)
moment!!!  (изучить)
koans

*************** ВОПРОСЫ  ***********************
'self' les8
'form-group'   les9
butStart.onclick = function clickStart() { почему в онклик сет интервал не вызыв сразу а в дескрипшн -- сразу?? les8
прав комментарии
запустить код в панели

примеси





*************************   les3
1. isTriangle ты проверяешь только одну сторону надо три втвоем случае isTriangle(1, 0, 2) будет треугольником,
2. findShort - не совсем понятно почему let shortest = 15;
надо было так let shortest = arrFromString[0].length

********                        les4
1. добавляй лучше полноценные коменты
/**
 *  division without remainder
 * @param a
 * @param b
  @returns {}
 */

2. vowels
можно не писать большые буквы только маленькие
и сделать str = str.toLowerString() ну или при сравнение

3.sumProducts - старайся делать функции с консистентными данными, функция должна возвращать ожидаемый результат,
 т.е если ты пишешь подсчет суммы то она должна возвращать число если продуктов нет то 0. т.к. если ты будешь использовать sum
 в других функциях возврат строки придется отдельно обрабатывать

4. cart.forEach(function (item, i, arrProd) {
		sumProd += +arrProd[i].costPerUnit * +arrProd[i].numberOfUnits;
	} );
тут наверное лучше item сразу брать, смысла нет добавлять массив и индекс брать
sumProd += +current.costPerUnit * +current.numberOfUnits;

5. removeProd тоже что и в 4 и там лучше фильтр юзать
и то же самое если возвращаешь cart то если cart пустая то лучше вернуть []

*******************       les5

функция сравнения, ты даты сравниваешь как строки, если у тебя в будущем придет объект с другим форматом даты что то может пойти не так,
 всегда старайся думать о переиспользовании и расширяемости
**********************      les7

можно было получать arguments , конвертить его в массив и применять не call а apply с массивом который получили из arguments,
 предварительно в него добавив оставшиеся параметры
*********************             les8
при copy past всегда убедись что копируемые функции абсолютно идентичны..
принцип единственной ответственности и пр. открытости/закрытости для функций(класса)


*************************** ESLINT ***********************
toMatch
toBeDefined
toBeNull
toBeTruthy
toContain
toBeLessThan toBeGreaterThan
toBeCloseTo  точн матем сравнение
toThrow
toThrowError
..spyOn...
toHaveBeenCalled   - что был вызван  toHaveBeenCalledWith - был вызван с аргументами
and.callThrough   - перехват выполнения
and.returnValue  - все вызовы функции будут возвращать определенное значение.
and.callFake    - все вызовы шпиону будут делегированы предоставленной функции
and.throwError   - всеми вызовами шпиону throw указанное значение будет считаться ошибкой.
and.stub    -   исходное поведение 'окурка' может быть возвращено в любое время с помощью
.calls.any(): возвращает, false если шпион вообще не был вызван, а затем true один раз произойдет хотя бы один вызов.
.calls.count(): возвращает количество вызовов шпиона
.calls.argsFor(index): возвращает аргументы, переданные на номер вызова index

.calls.allArgs(): возвращает аргументы для всех вызовов
.calls.all(): возвращает контекст (the this) и аргументы, переданные всем вызовам
.calls.mostRecent(): возвращает контекст (the this) и аргументы для самого последнего вызова
.calls.first(): возвращает контекст (the this) и аргументы для первого вызова
.calls.first().object --  "object-свойство" устанавливается равным значению, thisкогда был вызван шпион
expect(foo).toHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));

.calls.reset(): очищает все отслеживания для шпиона
expect({}).toEqual(jasmine.any(Object));
jasmine.objectContaining  -- когда ожидание заботится только об определенных парах ключ / значение в фактическом.
jasmine.clock().install     jasmine.clock().tick    --- для таймаутов

